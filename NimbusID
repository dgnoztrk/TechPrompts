YOUR TASK:
Build a production-ready Identity and Access Management (IAM) system as an alternative to Keycloak. Technology stack: .NET Core 10. Architecture: Clean Architecture. Projects: Api (ASP.NET Core Web API) and Web (ASP.NET Core MVC). Layers: Domain, Application, Infrastructure + Api + Web. There will be NO separate Presentation layer; only these layers must exist.
The Web project will manage both the User Console and the Admin Console from a SINGLE MVC project. Admin and User consoles MUST NOT call the API; they must connect directly to the database via Infrastructure repositories/UnitOfWork. The API is used only for external authentication/authorization via OAuth2/OIDC.

CRITICAL RULES:
- .NET Core 10 must be used.
- UI: ASP.NET Core MVC (Web project).
- API: ASP.NET Core Web API (Api project).
- Clean Architecture: Domain, Application, Infrastructure layers, plus Api and Web projects.
- User and Admin panels must be managed from one MVC project using jQuery and Bootstrap (latest stable versions).
- All JavaScript logic must be written in jQuery.
- All UI rendering must be done with Bootstrap.
- UX is critical: mimic Keycloak’s Admin Console and Account Console as closely as possible (ideally near-identical). Sidebar layout, tables, filters, modals, breadcrumbs, realm selector, top navigation, and overall look & feel should resemble Keycloak.
- A DataSeeder must run at startup:
  - Default user: username='admin', password='Admin123!' (store as hashed)
  - Automatically create a 'Master' realm
  - Automatically create a client named 'default' under the Master realm
  - The admin user must belong to the Master realm and have appropriate admin roles
- Only PostgreSQL is allowed.
- The Web MVC project must automatically apply EF Core migrations at startup.
- PostgreSQL DateTime values must be stored as LOCAL time (DateTime.Now), NOT UTC.
  - DbContext must include:
    AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
    AppContext.SetSwitch("Npgsql.DisableDateTimeInfinityConversions", true);
- Roles and permissions must be carefully designed; the entire system must work smoothly without gaps.

OUT OF SCOPE (STRICTLY FORBIDDEN):
- No LDAP
- No Active Directory
- No Kerberos
- No SAML
(No classes, endpoints, configs, or references related to these technologies.)

SYSTEM SCOPE (KEYCLOAK-LIKE, EXCLUDING LDAP/AD/KERBEROS/SAML):

1) AUTHENTICATION
- Username + password login
- Optional or mandatory email verification
- Forgot password / password reset
- Force password change on first login
- Brute force protection:
  - Failed login attempts threshold
  - Lockout duration
  - Progressive delay
- MFA / 2FA:
  - TOTP (RFC6238 compatible; Google Authenticator, Authy)
  - Recovery codes
  - MFA can be optional, mandatory, or policy-based
- WebAuthn / FIDO2 (at least architectural support or placeholders)
- Authentication flows (Keycloak-style):
  - Username+Password → MFA → Required Actions
  - Required actions: verify email, update password, configure TOTP, accept terms (optional)
- Social login via external OIDC providers:
  - Google, GitHub, Microsoft, etc.
  - Stored as Identity Providers in DB (OIDC/OAuth2 only)
  - Dynamic “Login with X” buttons on login screen

2) AUTHORIZATION
- Role-Based Access Control (RBAC):
  - Realm roles
  - Client roles
  - Composite roles
  - Default roles
- Group-based role assignment
- Policy & Permission-based authorization (Keycloak Authorization Services–like):
  - Resource definitions
  - Scope definitions
  - Permissions = Resource + Scope + Policy
  - Policy types:
    - Role-based
    - Group-based
    - Attribute-based (ABAC)
    - Time-based
    - IP-based (CIDR)
  - Policy evaluation engine for runtime authorization checks
- Fine-grained admin permissions:
  - Admins can be restricted to specific realms or clients

3) SSO / SLO & SESSION MANAGEMENT
- Single Sign-On across clients within a realm
- Single Logout:
  - Global logout
  - Client-specific logout
- Session management:
  - Active user sessions list
  - Admin session revocation
  - Idle timeout & max lifespan
  - “Remember me”
  - Concurrent session limits (optional)

4) OIDC / OAUTH2 PROTOCOL (API PROJECT)
Implement full OAuth2/OIDC endpoints:
- /.well-known/openid-configuration
- /protocol/openid-connect/auth
- /protocol/openid-connect/token
- /protocol/openid-connect/userinfo
- /protocol/openid-connect/logout
- /protocol/openid-connect/certs (JWKS)
- /protocol/openid-connect/introspect
- /protocol/openid-connect/revoke

Supported flows:
- Authorization Code + PKCE (public clients)
- Authorization Code (confidential clients)
- Client Credentials (service accounts)
- Refresh Token

Tokens:
- JWT (RS256)
- JWK key management with rotation
- Access token, refresh token, ID token
- Claims:
  - sub, iss, aud, exp, iat
  - realm roles
  - client roles
  - groups
  - custom user attributes (via protocol mappers)
- Token settings:
  - Access token lifespan
  - Refresh token lifespan
  - Offline tokens (optional; at least architecture)

5) CLIENT MANAGEMENT
- Public vs Confidential clients
- Redirect URI whitelist
- Post-logout redirect URIs
- Allowed CORS origins
- PKCE enforcement
- Client secret rotation
- Client scopes (default & custom)
- Protocol mappers:
  - User attribute → token claim
  - Role → claim
  - Group → claim
  - Hardcoded claims

6) REALM MANAGEMENT (MULTI-TENANT)
- Multiple realms
- Full isolation per realm
- Realm settings:
  - Login (password policy, brute force)
  - Tokens
  - Themes
  - Email (SMTP)
- Realm export/import (JSON)
- Realm cloning (optional)

7) USER MANAGEMENT
Admin Console:
- Create/update/disable users
- Reset credentials
- Required actions
- Role & group assignments
- User attributes
- Active sessions & revoke
User Console:
- Profile management
- Change password
- MFA configuration (QR + verification)
- View/logout sessions
- Authorized applications
- Consent management (optional)

8) GROUPS & ORGANIZATION
- Hierarchical groups
- Group attributes
- Group-role mappings

9) EVENTS & AUDIT LOGGING
- Login success/failure
- Brute force lock events
- Token issue/refresh/revoke
- Admin actions
- Stored in DB
- Filterable UI (date, user, type, IP)

10) THEMING & UI CUSTOMIZATION
- Customizable login, admin, and account themes
- Bootstrap themes + custom CSS
- Multi-language support (at least EN/TR)
- Keycloak-like layout:
  - Sidebar navigation
  - Topbar with realm selector
  - Tab-based pages
  - Breadcrumbs
  - Searchable, paginated tables

11) EXTENSIBILITY (ARCHITECTURE READY)
- SPI-like design:
  - IEventSink
  - ITokenEnhancer
  - IPolicyEvaluator
- Default Infrastructure implementations
- Easy to extend later

ARCHITECTURE & PROJECT STRUCTURE:
Solution:
- src/
  - Domain/
  - Application/
  - Infrastructure/
  - Api/
  - Web/

Domain Layer:
- Entities (aggregate roots, value objects)
- Domain events (optional)
- Enums
- BaseEntity:
  - Id (Guid)
  - CreatedAt, UpdatedAt (DateTime.Now)
  - CreatedBy, UpdatedBy
  - IsDeleted (soft delete)
- All DateTime fields use local time (DateTime.Now)

Application Layer:
- Services / Use cases:
  - AuthService
  - TokenService
  - RealmService
  - ClientService
  - UserService
  - RoleService
  - GroupService
  - AuthorizationService
  - AuditService
- DTOs
- Validation (FluentValidation)
- Result pattern
- Security abstractions (hashing, TOTP, encryption)

Infrastructure Layer:
- EF Core + Npgsql
- Repositories & UnitOfWork
- DbContext with required AppContext switches
- Password hashing (Argon2id preferred, else PBKDF2)
- JWT signing keys (RSA, encrypted storage)
- TOTP implementation
- SMTP email sender
- Audit event storage

Api Project:
- OAuth2/OIDC endpoints
- Swagger/OpenAPI
- Rate limiting
- Exception middleware
- Serilog logging
- Health checks

Web Project:
- MVC + Razor
- Areas:
  - Admin
  - Account
- jQuery + Bootstrap (latest)
- Direct DB access via Infrastructure
- Auto migration + seeding at startup
- Cookie-based auth
- Keycloak-like login page per realm

DATA MODEL (DOMAIN ENTITIES – MUST BE COMPLETE):
Create (at minimum) the following entities:
- Realm
- Client
- User
- Credential
- Role
- RoleComposite
- Group
- UserGroup
- UserRole
- GroupRole
- ClientScope
- ClientClientScope
- ProtocolMapper
- AuthorizationResource
- AuthorizationScope
- AuthorizationPolicy
- AuthorizationPermission
- UserSession
- ClientSession
- RefreshToken
- SigningKey (JWK)
- IdentityProvider (OIDC/OAuth2 only)
- AuditEvent
- PasswordPolicy / RealmSettings owned types
- BruteForceProtectionSettings owned type

EF CORE:
- Navigation-based relationships
- Global query filters for soft delete
- Unique indexes:
  - Realm.Name
  - (RealmId, Client.ClientId)
  - (RealmId, User.Username)
  - (RealmId, Role.Name, ClientId)
  - Group.Path per realm
- Careful cascade rules

SECURITY:
- Strong password hashing
- Encrypted secrets
- CSRF protection
- XSS protection + CSP
- Rate limiting
- Brute force defense
- Full audit logging

DATA SEEDER:
- Idempotent
- Creates:
  - Master realm
  - Default client
  - admin / Admin123!
  - Admin roles and assignments

MIGRATION:
- Web startup:
  - db.Database.Migrate()
  - Run DataSeeder

UI SCREENS (KEYCLOAK-LIKE):
Admin:
- Dashboard
- Users
- Clients
- Roles
- Groups
- Authentication
- Realm Settings
- Events
Account:
- Profile
- Password
- MFA
- Sessions
- Applications

DELIVERABLE:
1) Full solution & projects
2) Complete domain entities
3) EF Core + migrations + seeder
4) Fully working OAuth2/OIDC
5) Web Admin & Account consoles (Bootstrap + jQuery)
6) admin/Admin123! login works on first run
7) PostgreSQL DateTime local behavior enforced
8) Smooth, complete authorization model

START NOW:
First create the solution structure, then Domain entities, then Infrastructure EF & Seeder, then API OIDC endpoints, and finally the Web UI.
